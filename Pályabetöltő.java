//
//
//  Generated by StarUML(tm) Java Add-In
//	Modified by Harangozó
//	@Last modification: 2016.04.29.
//
//  @ Project : Grafikus
//  @ File Name : Pályabetöltő.java
//  @ Generation date : 2016.03.28.
//  @ Author : kifli csapat
//
//

import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Random;

import javax.xml.transform.Templates;

public class Pályabetöltő {
	private DinamikusMező[][] DinamikusMátrix;	//ebből lesz a dinamikus struktúra
	private StatikusMező[][] StatikusMátrix;	//a statikus struktúrához tartozó mátrix
	private Ezredes ezredes;	//a pályabetöltővel létrejött ezredes
	private Jaffa jaffa;	//a pályáról származó jaffa
	private ArrayList<Replikátor> replikátor;	//a replikátorok listája
	private DinamikusMező hiddenZPMMező;	//az a rejtett ZPM helye, ahol meg fog jelenni a megfelelő időpontban a ZPM
	private String textúrákElérésiÚtvonala;	//a textúrák elérési útvonala, amit a pályafileból olvas be
	private static int magasságiFelosztás;	//az y felosztás, egy statikushoz hány dinamikus tartozik magasságban
	private static int szélességiFelosztás;	//az x felosztás
	private static boolean resize; 	//textúrák átméretezésének engedélyezése 
	
	public Pályabetöltő(){	//konstruktor, ami mindent kezdetileg inicializál
		hiddenZPMMező=null;
		ezredes=null;
		jaffa=null;
		replikátor=null;
		DinamikusMátrix=null;
		StatikusMátrix=null;
		magasságiFelosztás=0;
		szélességiFelosztás=0;
		resize = true; 	//alapértelmezésben engedélyezve
	}
	
	public DinamikusMező getHiddenZpm(){	//a rejtett ZPM helyét adja vissza, vagy nullt
		DinamikusMező temp = hiddenZPMMező;
		hiddenZPMMező=null;
		return temp;
	}
		
	public static int getMagasságiFelosztás() {	//az Y felosztást adja vissza
		return magasságiFelosztás;
	}
	
	public static int getSzélességiFelosztás() {	//az x felosztást adja vissza
		return szélességiFelosztás;
	}
	
	public static boolean getResize(){
		return resize;
	}
	
	public Ezredes getEzredes() {	//a pályafileból létrehozott ezredest adja vissza
		return ezredes;
	}
	
	public Jaffa getJaffa() {	//a jaffát adja vissza
		return jaffa;
	}
	
	public ArrayList<Replikátor> getReplikátor() {	//a replikátorok listáját adja vissza
		return replikátor;
	}
	
	public void pályaBeolvas(String elérésiÚtvonal){ //Beolvassa a mátrixokba a pályát, az elérésiÚtvonal alapján
		
		class sorFeldolgozó{	//Egy belső osztály, ami elintézi egy sor feldolgozását
			//https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html
			int szélesség;	//szélességi index
			int magasság;	//magassági index
			int ZPMekSzáma;	//a pályán található ZPM ek száma.
			
			String előFeldolgozó(String kommentezettSor){	//a metódus feladata, a kommentek kiszedése a // után és a tabulátorok szóközre cserélése
				String[] tmp = null;
				if (kommentezettSor.contains("\t")) kommentezettSor = kommentezettSor.replace("\t", " ");	//minden tabulátort szóközre cserélünk
				if (kommentezettSor.contains("//")){	//ha van a sorban kifejezetten komment // jellel megelőzően
					tmp = kommentezettSor.split("//");	//kettészedi a sort a "//" mentén
					return tmp[0];	//visszatér a legelső // előtt található résszel
				}
				else {
					return kommentezettSor;	//különben komment nem volt benne, ezért az előfeldolgozó visszaadja a sort módosítatlanul
				}
			}

			void sorFeldolgoz(String sor){
				String sor2 = előFeldolgozó(sor);	//eltávolítjuk a sorból a // utáni részt, ha van benne
				String[] elemek;	//ez fogja tárolni a sorban tárolt bemeneti értékeket
				elemek = sor2.split(" ");	//a komment nélküli sort a szóközök mentén feldaraboljuk bemeneti értékekre
				
				int l=elemek.length;	//hány bemeneti érték van a sorban
				
				if(l==0) return;	//ha nincs a sorban mit feldolgozni, akkor az vagy üres sor, vagy csak komment volt
				if(l==1){	//ha csak egy elem van a sorban, az a ZPM ek száma lesz, vagy a textúrák elérése
					if(textúrákElérésiÚtvonala==null){	//a textúrák elérése még nem volt, akkor először az van
						textúrákElérésiÚtvonala=sor2;	//az elérési útvonala a textúrák listának beállítása
					} else {
						try {	//átalakítjuk a szöveget számmá
							ZPMekSzáma=Integer.parseInt(elemek[0]);
						} catch (NumberFormatException e) {
							System.err.println("A ZPMek száma nem szám formátumú:");
							e.printStackTrace();
						}
					}
				}
				if(l==2){	//ha csak a két index szerepel, akkor az a pálya mérete, vagy a felosztása a Dinamikusnak a Statikushoz képest
					if(magasságiFelosztás==0 && szélességiFelosztás==0){	//ha még a felosztás nem definiált akkor azt jelenti a sorban lévő adatok
						try {	//az felbontás értékeit számmá alakítjuk
							szélességiFelosztás=Integer.parseInt(elemek[0]);	//első érték a DinamikusMetzők száma egy sorban a StatikusMezőben
							magasságiFelosztás=Integer.parseInt(elemek[1]);	//a második érték a DinamikusMezők száma egy oszlopban a StatikusMezőben
							resize = false;
						} catch (NumberFormatException e) {
							System.err.println("A dinamikus mező felbontása a statikushoz képest nem szám:");
							e.printStackTrace();
						}
					} else {	//ha a felbontás már definiálva van, akkor a StatkiusMezők számát írja le az adatok
						int sz=1;	//a pálya méretét tárolja, az oszlopok száma
						int m=1;	//a pálya méretét tárolja, a sorok száma
						
						try {	//az pálya méretének az értékeit számmá alakítjuk
						sz=Integer.parseInt(elemek[0]);	//első érték a pálya oszlopainak száma
						m=Integer.parseInt(elemek[1]);	//a második érték a pálya sorainak a száma
						} catch (NumberFormatException e) {
							System.err.println("A pálya mérete nem szám:");
							e.printStackTrace();
						}
						
						DinamikusMátrix = new DinamikusMező[m*magasságiFelosztás][sz*szélességiFelosztás];	//létrehozunk egy 2D DinamikusMező tömböt az adott méretekkel beszorozva a felbontással
							for(int i=0; i<m*magasságiFelosztás;i++)	//minden sorban
								for(int j=0; j<sz*szélességiFelosztás; j++) DinamikusMátrix[i][j]= new DinamikusMező();	//a tömb mezőit feltöltjük
						StatikusMátrix = new StatikusMező[m][sz];	//létrehozunk egy 2D StatikusMező mátrixot, a megadott méretekkel
							for(int i=0; i<m;i++)	//minden sorban
								for(int j=0; j<sz; j++) StatikusMátrix[i][j]= new StatikusMező();	//a tömb mezőit feltöltjük
					}
				}
				
				if(l>2){	
					if(magasságiFelosztás==0 && szélességiFelosztás==0){	//ha még a felosztás nem definiált akkor azt jelenti a sorban lévő adatok
						try {	//az felbontás értékeit számmá alakítjuk
							szélességiFelosztás=Integer.parseInt(elemek[0]);	//első érték a DinamikusMetzők száma egy sorban a StatikusMezőben
							magasságiFelosztás=Integer.parseInt(elemek[1]);	//a második érték a DinamikusMezők száma egy oszlopban a StatikusMezőben
							if (elemek[2].equals("resize")) resize = true;
							else resize = false;
						} catch (NumberFormatException e) {
							System.err.println("A dinamikus mező felbontása a statikushoz képest nem szám:");
							e.printStackTrace();
						}
					}
					
					
					//ha több mint 2 paraméter van a sorban, az valamilyen építőelemet, pályaelemet ír le
					try {	//az indexeket számokká alakítjuk
						szélesség=Integer.parseInt(elemek[0]);
						magasság=Integer.parseInt(elemek[1]);
					} catch (NumberFormatException e) {
						System.err.println("A pályaelemhez tartozó indexek nem számok:");
						e.printStackTrace();
					}
						
						
					try{	//a paraméterben kapott Pályaelem azonosítóra rá switchelünk
						switch(elemek[2].charAt(0)){
						case '#':	//szakadék
							szakadékLe();
							break;
						case 'F':	//fal
							falLe();
							break;
						case 'S':	//speciális fal
							specLe();
							break;
						case 'A':	//ajtó
							ajtóLe();
							break;
						case 'M':	//mérleg
							if(l==6) mérlegLe(Integer.parseInt(elemek[3]),Integer.parseInt(elemek[4]),Integer.parseInt(elemek[5]));
							if (l==4) mérlegLe(Integer.parseInt(elemek[3]));
							if(l==3) mérlegLe();
							break;
						case 'D':	//doboz
							if (elemek.length==3)dobozLe();	//ha 3 paraméter van a sorban, és D, akkor egy dobozt lerakt adott helyre
							else{	//amugy, meg több paraméter van
								 if (elemek[3].charAt(0)=='R'){		//ha a 4. paraméter R akkor az randomizálja a doboz helyét a pályaelemen belül
										Random rand = new Random();	//egy randomgenerátor
										int magasság2=(magasság/magasságiFelosztás)*magasságiFelosztás;	//északra a pályaelem széle
										int szélesség2=(szélesség/szélességiFelosztás)*szélességiFelosztás;	//nyugatra a pályaelem széle
										magasság2+=rand.nextInt(magasságiFelosztás);	//a magassági felosztásban random hozzáadunk pluszba a szélétől
										szélesség2+=rand.nextInt(szélességiFelosztás);	//random hozzáadunk, hogy keletre mozduljon
										magasság=magasság2;	//beállítjuk a magasságot a most számoltra
										szélesség=szélesség2;	//beállítjuk a szélességet a kalkuláltra
										dobozLe();	//ezután, hogy a koordinátákat bemódosítottuk, lerakhatjuk a dobozt
								}	
							}
							break;
						case 'Z':	//zpm
							if(elemek.length==3) zpmLe();	//ha a ZPM simán plussz paraméter nélkül szerepel, lerakjuk
							else {
								if (elemek[3].charAt(0)=='H')	//ha plussz paraméter H, akkor 
									hiddenZPMMező=DinamikusMátrix[magasság][szélesség];	//az a ZPM rejtet, ezért csak a helyét tároljuk el
							}
							break;
						case 'E':	//ezredes
							ezredesLe();
							break;
						case 'J':	//jaffa
							jaffaLe();
							break;
						case 'P':
							padlóLe();
							break;
						case 'R':	//replikátor
							replikátorLe();
							break;
						default:
							break;
						}
					}
					catch (NullPointerException e) {	//ha egy Pályaelem hamarabb van mint ahogy a pálya mérete, akkor még nincs pálya ahova indexelhetünk
						System.err.println("A pálya mérete még nem definiált, a mátrixok nem léteznek, rossz a pályafile sorainak sorrendje:");
						e.printStackTrace();
					}
				}
		}
			
			void padlóLe(){	//lerak egy padlót
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(new Padló());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Padlót nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}
			}

			void falLe(){	//falat ad hozzá a statikushoz
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(new Fal());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Falat nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}
				
			}

			void specLe(){	//speciális falat ad hozzá a statikushoz
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(new SpeciálisFal());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Speciális falat nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}
			}
			
			void mérlegLe(){	//lerak egy mérleget
				Mérleg mérleg = new Mérleg(null, 0);
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(mérleg);	//a létrehozott mérleget lerakjuk a StatikusMezőre
					} catch (IndexOutOfBoundsException e) {
						System.err.println("Üres mérleget nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
						e.printStackTrace();
					}
			}
			void mérlegLe(int tömegHatár){
				Mérleg mérleg = new Mérleg(null, tömegHatár);
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(mérleg);	//a létrehozott mérleget lerakjuk a StatikusMezőre
					} catch (IndexOutOfBoundsException e) {
						System.err.println("Üres mérleget nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
						e.printStackTrace();
					}
			}

			void mérlegLe(int tömegHatár,int ajtóSzélességi, int ajtóMagassági){	//mérleget ad hozzá a StatikusMezőhöz
				Ajtó temp=null;	//a mérleg erre az ajtóra lesz bekötve, annak a mérleget definiáló sor előtt kell szerepelnie
				Pályaelem ref=null;
				
				try {
				ref = StatikusMátrix[ajtóMagassági][ajtóSzélességi].getPályaelem();	//a mérleghez tartozó pályaelem
				} catch (IndexOutOfBoundsException e) {
					System.err.println("A mérleghez tartozó ajtó pozíció-indexei nem megfelelők:");
					e.printStackTrace();
				}
				
				if(ref.valtozhatEAkadalyMivolta()) temp =(Ajtó)ref;	//ha az valóban ajtó, akkor átkasztoljuk, és az tempnek értékül adjuk, egyébként marad null
				Mérleg mérleg = new Mérleg(temp, tömegHatár);	//létrehozzuk a mérleget, ami a temp ajtót fogja tudni vezérelni, ha nem null
				
				try {
				StatikusMátrix[magasság][szélesség].setPályaelem(mérleg);	//a létrehozott mérleget lerakjuk a StatikusMezőre
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Mérleget nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők: "+magasság+"x, "+szélesség+"y");
					e.printStackTrace();
				}
			}

			void ajtóLe(){	//ajtót ad hozzá a statikushoz
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(new Ajtó());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Ajtót nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}
			}

			void szakadékLe(){	//szakadékot rak le a statikusra				
				try {
					StatikusMátrix[magasság][szélesség].setPályaelem(new Szakadék());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Szakadékot nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}
			}

			void dobozLe(){	//lerak egy dobozt a dinamikusra

				try {
					DinamikusMátrix[magasság][szélesség].setTárgy(new Doboz());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Dobozt nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}				
			}

			void zpmLe(){	//lerak egy zpm-et a dinamikusra
				try {
					DinamikusMátrix[magasság][szélesség].setTárgy(new ZPM());
				} catch (IndexOutOfBoundsException e) {
					System.err.println("ZPMet nem lehetett lerakni a mátrixba, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}	
			}

			void ezredesLe(){	//lerak egy ezredest a dinamikusra
				ezredes = new Ezredes(ZPMekSzáma);	//az ezredest létrehozzuk egy fegyverrel, és a ZPMek számával
				
				try {	//lerakjuk a mátrixba a létrehozott ezredest
					DinamikusMátrix[magasság][szélesség].setEzredes(ezredes);
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Ezredest nem lehetett lerakni, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}	
				
				try {	//eltároljuk az ezredesben, hogy melyik mezőben van éppen
					ezredes.setPozíció(DinamikusMátrix[magasság][szélesség]);
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Ezredes helyzetét nem lehetett beállítan, mert az indexek nem megfelelőkí:");
					e.printStackTrace();
				}
			}

			void jaffaLe(){		//lerak egy jaffát a dinamikusra
				jaffa = new Jaffa(ZPMekSzáma);	//a jaffát létrehozzuk egy fegyverrel, és a ZPMek számával
				
				try {	//lerakjuk a mátrixba a létrehozott jaffát
					DinamikusMátrix[magasság][szélesség].setEzredes(jaffa);
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Jaffát nem lehetett lerakni, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}	
				
				try {	//eltároljuk a jaffában, hogy melyik mezőben van éppen
					jaffa.setPozíció(DinamikusMátrix[magasság][szélesség]);
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Jaffa helyzetét nem lehetett beállítan, mert az indexek nem megfelelőkí:");
					e.printStackTrace();
				}
			}
			
			void replikátorLe(){	//lerak egy replikátort a dinamikusra
				if(replikátor==null) replikátor=new ArrayList<Replikátor>(); //létrehozunk egy replikátor listát, ha nincs
				Replikátor hozzáadandó = new Replikátor();	//létrehozunk egy replikátort amit hozzá fogunk adni a listához

				try {	//lerakjuk a mátrixba a létrehozott replikátort
					DinamikusMátrix[magasság][szélesség].setReplikátor(hozzáadandó);
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Replikátor nem lehetett lerakni, mert az indexek nem megfelelők:");
					e.printStackTrace();
				}	
				
				try {	//eltároljuk a replikátorban, hogy melyik mezőben van éppen
					hozzáadandó.setPozíció(DinamikusMátrix[magasság][szélesség]);
				} catch (IndexOutOfBoundsException e) {
					System.err.println("Replikátor helyzetét nem lehetett beállítan, mert az indexek nem megfelelőkí:");
					e.printStackTrace();
				}
				replikátor.add(hozzáadandó);
			}
		}//a segédosztály implementációjának vége
		
		String sor=null;	//a sorokat ide olvassuk majd be
		sorFeldolgozó feldolgozó = new sorFeldolgozó();	//példányosítjuk a segéosztályt
		
		BufferedReader reader=null;	//Üres buffer reader
		try {
			reader = new BufferedReader(new FileReader(elérésiÚtvonal));	//az elérési útvonalon levő filet megnyitjuk
			
			while ((sor = reader.readLine()) != null) {	//soronként beolvassuk a filet
				feldolgozó.sorFeldolgoz(sor);	//minden sort feldolgozunk
			}//a folyamat végére a teljes pályafilet feldolgoztuk, annak alapján létrehoztuk a pályát
		}
		catch (FileNotFoundException e) {	//Ha az elérési útvonal hibás, akkor a file nem nyitható meg
			System.err.println("A pályafile elérési útvonala hibás, a file nincs meg:");
			e.printStackTrace();
		} catch (IOException e) {
			System.err.println("IO kivétel volt a pályafile elérésekor:");
			e.printStackTrace();	//Ha io kivétel volt, kiírjuk a stacket
		}
		finally {
		    try {
				reader.close();	//Lezárjuk a readert
			} catch (IOException e) {
				System.err.println("IO kivétel volt a pályafile lezárásakor:");
				e.printStackTrace();	//Ha nem volt reader akkor a StackTracet kiírjuk
			}
		}
	}
	
	public DinamikusMező pályaLétrehoz() {	//összefűzi a mátrix elemeit szomszédossági hálóba és a Mátrix párokat összerendeli
		int szel=0;	//a pálya szélessége, a mátrix oszlopainak száma, második index
		int mag=0;	//a pálya magassága, a mátrix sorainak a száma, első index
		
		if(StatikusMátrix!=null) {	//ha már létrehoztuk a mátrixot,
			mag = StatikusMátrix.length;	//a két dimenziós tömb hány tömböt tartalmaz, a sorok száma
			if(StatikusMátrix[0]!=null) szel=StatikusMátrix[0].length;	//a tömbök hány eleműek, az oszlopok száma
		} else{	//egyébként nem tudunk pályát készíteni
			System.err.println("A pályát nem lehetett létrehozni, mert nincs pálya beolvasva.");
			return null;
		}
		
		for(int i=0;i<mag*magasságiFelosztás; i++)	//itt rendeli össze az összetartozó párokat
			for(int j=0;j<szel*szélességiFelosztás;j++)	//minden DinamikusMezőhöz a neki megfeleltethető StatikusMezőt
				DinamikusMátrix[i][j].setPár(StatikusMátrix[i/magasságiFelosztás][j/szélességiFelosztás]);	//a DinamikusMezőket hozzárendeli a megfelelő felosztás mellet a StatikusMezőhöz
		
		for (int sz = 0; sz < szel*szélességiFelosztás; sz++) {	//a DinamikusMátrix elemeit rendeli össze Kelet Déli irányba
			for(int m = 0; m<mag*magasságiFelosztás; m++){	//az m a magassági futó paraméter, az sz a szélességi
				if((sz+1)<szel*szélességiFelosztás){	//ha a DinamikusMezőtöl keletre még érvényes az index
					if((m+1)<mag*magasságiFelosztás){	//ha a déli szomszéd indexe még érvényes
						DinamikusMátrix[m][sz].setSzomszéd(Irány.e, DinamikusMátrix[m][sz+1]);	//a keleti szomszéd beállítása
						DinamikusMátrix[m][sz].setSzomszéd(Irány.s, DinamikusMátrix[m+1][sz]);	//a déli szomszéd beállítása
					}else {	//déli szomszéd nincs, de keletre még van
						DinamikusMátrix[m][sz].setSzomszéd(Irány.e, DinamikusMátrix[m][sz+1]);	//a keleti szomszédot beállítjuk
					}
				} else {	//keletre már nincs szomszéd
					if((m+1)<mag*magasságiFelosztás){	//ha délre még van szomszéd
						DinamikusMátrix[m][sz].setSzomszéd(Irány.s, DinamikusMátrix[m+1][sz]);	//a déli szomszéd beállítása
					}
				}
			}		
		}
		
		for (int sz = 0; sz < szel; sz++) {	//a StatikusMátrix elemeit rendeli össze Kelet Déli irányba
			for(int m = 0; m<mag; m++){	//az m a magassági futó paraméter, az sz a szélességi
				if((sz+1)<szel){	//ha a StatikusMezőtöl keletre még érvényes az index
					if((m+1)<mag){	//ha a déli szomszéd indexe még érvényes
						StatikusMátrix[m][sz].setSzomszéd(Irány.e, StatikusMátrix[m][sz+1]);	//a keleti szomszéd beállítása
						StatikusMátrix[m][sz].setSzomszéd(Irány.s, StatikusMátrix[m+1][sz]);	//a déli szomszéd beállítása
					}else {	//déli szomszéd nincs, de keletre még van
						StatikusMátrix[m][sz].setSzomszéd(Irány.e, StatikusMátrix[m][sz+1]);	//a keleti szomszédot beállítjuk
					}
				} else {	//keletre már nincs szomszéd
					if((m+1)<mag){	//ha délre még van szomszéd
						StatikusMátrix[m][sz].setSzomszéd(Irány.s, StatikusMátrix[m+1][sz]);	//a déli szomszéd beállítása
					}
				}
			}		
		}
		
		for (int sz = szel*szélességiFelosztás-1; sz>=0 ; sz--) {	//a DinamikusMátrix elemeit rendeli össze Nyugat Északi irányba
			for(int m = mag*magasságiFelosztás-1; m>=0; m--){	//az m a magassági futó paraméter, az sz a szélességi
				if((sz-1)>=0){	//ha a DinamikusMezőtöl Nyugatra még érvényes az index
					if((m-1)>=0){	//ha az északi szomszéd indexe még érvényes
						DinamikusMátrix[m][sz].setSzomszéd(Irány.w, DinamikusMátrix[m][sz-1]);	//a nyugati szomszéd beállítása
						DinamikusMátrix[m][sz].setSzomszéd(Irány.n, DinamikusMátrix[m-1][sz]);	//az északi szomszéd beállítása
					}else {	//északi szomszéd nincs, de nyugatra még van
						DinamikusMátrix[m][sz].setSzomszéd(Irány.w, DinamikusMátrix[m][sz-1]);	//a nyugati szomszédot beállítjuk
					}
				} else {	//nyugatra már nincs szomszéd
					if((m-1)>=0){	//ha északra még van szomszéd
						DinamikusMátrix[m][sz].setSzomszéd(Irány.n, DinamikusMátrix[m-1][sz]);	//az északi szomszéd beállítása
					}
				}
			}		
		}

		for (int sz = szel-1; sz>=0 ; sz--) {	//a StatikusMátrix elemeit rendeli össze Nyugat Északi irányba
			for(int m = mag-1; m>=0; m--){	//az m a magassági futó paraméter, az sz a szélességi
				if((sz-1)>=0){	//ha a StatikusMezőtöl Nyugatra még érvényes az index
					if((m-1)>=0){	//ha az északi szomszéd indexe még érvényes
						StatikusMátrix[m][sz].setSzomszéd(Irány.w, StatikusMátrix[m][sz-1]);	//a nyugati szomszéd beállítása
						StatikusMátrix[m][sz].setSzomszéd(Irány.n, StatikusMátrix[m-1][sz]);	//az északi szomszéd beállítása
					}else {	//északi szomszéd nincs, de nyugatra még van
						StatikusMátrix[m][sz].setSzomszéd(Irány.w, StatikusMátrix[m][sz-1]);	//a nyugati szomszédot beállítjuk
					}
				} else {	//nyugatra már nincs szomszéd
					if((m-1)>=0){	//ha északra még van szomszéd
						StatikusMátrix[m][sz].setSzomszéd(Irány.n, StatikusMátrix[m-1][sz]);	//az északi szomszéd beállítása
					}
				}
			}		
		}
		
		return DinamikusMátrix[0][0];
	}
	
	public ArrayList<String> vezérlőkBeolvasása(String elérésiÚtvonal){	//beolvassa a paraméterben kapott útvonalról a bineket
		ArrayList<String> ret = new ArrayList<String>();	//a bindek listája
		 
		 BufferedReader reader = null;
		 String sor = null;
		 try {
			reader = new BufferedReader(new FileReader(elérésiÚtvonal));
			while ((sor = reader.readLine()) != null){
				ret.add(sor);	//a bind fileban található sorokat hozzáadjuk ahhoz amit vissza fogunk adni
			}
		} catch (FileNotFoundException e) {
			System.err.println("A vezérlő gombok elérési útvonala hibás, a file nincs meg:");
			e.printStackTrace();
			
		} catch (IOException e) {
			System.err.println("IO kivétel volt a vezérlők elérésekor:");
			e.printStackTrace();	//Ha io kivétel volt, kiírjuk a stacket
		}
		 finally {
			try {
				reader.close();	//Lezárjuk a readert
			} catch (IOException e) {
				System.err.println("IO kivétel volt a vezérlő gombok lezárásakor:");
				e.printStackTrace();	//Ha nem volt reader akkor a StackTracet kiírjuk
			}
		}
		 return ret;
	}

	public String getTextúrákElérése() {	//visszaadja a textúrák elérési útvonalát, ami a pályafileban volt írva
		return textúrákElérésiÚtvonala;
	}
	
}